# R1.5.5 Kanban Dashboard â€” Implementation Plan (Backend)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Backend for the engineering roadmap Kanban dashboard â€” markdown parser, API endpoints, and FF7 worker assignment system.

**Architecture:** A pure-function markdown parser reads `docs/ENGINEERING_ROADMAP.md` and extracts structured task objects. Three API endpoints serve parsed tasks, worker stats, and assignment overrides. A `roadmap_worker` Supabase table stores manual worker overrides. Build-time git info injection provides commit metadata.

**Tech Stack:** Next.js 16 App Router, TypeScript, Supabase, existing FF7 theme constants.

**Design spec:** `docs/plans/2026-02-15-r1.5.5-kanban-dashboard-design.md`

---

## Task 1: Create `roadmap_worker` table

**Step 1: Create the table via Supabase MCP**

Use Supabase MCP `apply_migration` with this SQL:

```sql
CREATE TABLE IF NOT EXISTS roadmap_worker (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id text UNIQUE NOT NULL,
  worker text NOT NULL CHECK (worker IN ('cloud', 'tifa', 'barret', 'aerith', 'red_xiii')),
  assigned_at timestamptz NOT NULL DEFAULT now(),
  assigned_by text NOT NULL DEFAULT 'auto' CHECK (assigned_by IN ('auto', 'manual'))
);

COMMENT ON TABLE roadmap_worker IS 'FF7 worker assignments for engineering roadmap Kanban board';
```

**Step 2: Verify table exists**

Run `list_tables` via Supabase MCP to confirm `roadmap_worker` appears.

**Step 3: Commit** (nothing to commit â€” migration is in Supabase)

---

## Task 2: Create markdown parser

**Files:**
- Create: `src/lib/roadmap-parser.ts`

**Step 1: Create the parser**

Create `src/lib/roadmap-parser.ts` with the full parser implementation:

```typescript
/**
 * Parses docs/ENGINEERING_ROADMAP.md into structured RoadmapTask objects.
 * Pure function â€” no side effects, no database access.
 */

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface RoadmapTask {
  id: string;
  title: string;
  tier: string;
  status: 'backlog' | 'in_progress' | 'done';
  priority: string;
  effort: string;
  dependsOn: string[];
  specPath: string | null;
  checkboxes: { total: number; completed: number };
  description: string;
  costImpact: string | null;
  worker: string | null; // auto-assigned FF7 character key
  body: string; // raw markdown body for detail view
}

// â”€â”€â”€ FF7 Worker Auto-Assignment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export const WORKER_KEYWORDS: Record<string, string[]> = {
  cloud: ['api', 'agent', 'worker', 'pipeline', 'queue', 'supabase', 'migration', 'database', 'endpoint', 'route', 'backend'],
  tifa: ['component', 'page', 'ui', 'styling', 'form', 'card', 'detail', 'list', 'storyboard', 'frontend', 'button', 'modal'],
  barret: ['logging', 'versioning', 'deploy', 'redis', 'tls', 'config', 'env', 'cost', 'infrastructure', 'ci', 'cd'],
  aerith: ['spec', 'roadmap', 'design', 'plan', 'ux', 'review', 'acceptance', 'criteria'],
  red_xiii: ['test', 'validation', 'error', 'guard', 'boundary', 'security', 'audit'],
};

export const WORKER_INFO: Record<string, { name: string; color: string; role: string }> = {
  cloud: { name: 'Cloud Strife', color: '#4A90D9', role: 'Backend Lead' },
  tifa: { name: 'Tifa Lockhart', color: '#D94A6B', role: 'Frontend Lead' },
  barret: { name: 'Barret Wallace', color: '#8B6914', role: 'Infrastructure' },
  aerith: { name: 'Aerith Gainsborough', color: '#59B87A', role: 'PM / Design' },
  red_xiii: { name: 'Red XIII', color: '#D97A2A', role: 'QA / Review' },
};

/**
 * Auto-assign a worker based on keyword frequency in the task body.
 * Falls back to 'aerith' if no keywords match.
 */
export function autoAssignWorker(body: string): string {
  const lower = body.toLowerCase();
  const scores: Record<string, number> = {};

  for (const [worker, keywords] of Object.entries(WORKER_KEYWORDS)) {
    scores[worker] = 0;
    for (const kw of keywords) {
      // Count word-boundary matches to avoid partial matches
      const regex = new RegExp(`\\b${kw}\\b`, 'gi');
      const matches = lower.match(regex);
      if (matches) scores[worker] += matches.length;
    }
  }

  const sorted = Object.entries(scores).sort((a, b) => b[1] - a[1]);
  return sorted[0][1] > 0 ? sorted[0][0] : 'aerith';
}

// â”€â”€â”€ Tier Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const TIER_HEADERS: Record<string, string> = {
  'Tier 0': '0',
  'Tier 1:': '1',
  'Tier 1.5': '1.5',
  'Tier 2': '2',
  'Tier 3': '3',
  'Tier 4': '4',
};

function detectTier(headerLine: number, lines: string[]): string {
  // Walk backwards from the task header to find the parent ### Tier header
  for (let i = headerLine - 1; i >= 0; i--) {
    const line = lines[i];
    if (line.startsWith('### ')) {
      for (const [pattern, tier] of Object.entries(TIER_HEADERS)) {
        if (line.includes(pattern)) return tier;
      }
    }
  }
  return 'unknown';
}

// â”€â”€â”€ Status Detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function detectStatus(header: string, body: string): 'backlog' | 'in_progress' | 'done' {
  // Header patterns: ~~Title~~ DONE, ~~Title~~ FIXED, ~~Title~~ ~~DONE~~
  if (/~~.*~~\s*(DONE|FIXED|~~DONE~~)/i.test(header)) {
    return 'done';
  }

  // Header pattern: ðŸ”§ IN PROGRESS
  if (header.includes('IN PROGRESS')) {
    return 'in_progress';
  }

  // Body pattern: **Status:** Complete
  const statusMatch = body.match(/\*\*Status:\*\*\s*(.+)/i);
  if (statusMatch) {
    const statusText = statusMatch[1].toLowerCase();
    if (statusText.startsWith('complete')) return 'done';
    // Partial status like "Backend complete, frontend remaining" â†’ in_progress
    if (statusText.includes('complete')) return 'in_progress';
  }

  return 'backlog';
}

// â”€â”€â”€ Task ID & Title Extraction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function parseHeader(header: string): { id: string; title: string } | null {
  // Remove #### prefix
  let text = header.replace(/^####\s*/, '');

  // Remove strikethrough markers
  text = text.replace(/~~/g, '');

  // Remove status suffixes
  text = text.replace(/\s*(DONE|FIXED|IN PROGRESS)\s*/gi, '').trim();

  // Remove emoji
  text = text.replace(/ðŸ”§/g, '').trim();

  // Extract ID and title: "R1.7 - B-Roll Agent" or "B0.10 - Failed Pipeline..."
  const match = text.match(/^([RB]\d+\.?\d*\.?\d*)\s*-\s*(.+)$/);
  if (!match) return null;

  return { id: match[1], title: match[2].trim() };
}

// â”€â”€â”€ Field Extraction from Body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function extractField(body: string, field: string): string {
  const regex = new RegExp(`\\*\\*${field}:\\*\\*\\s*(.+)`, 'i');
  const match = body.match(regex);
  return match ? match[1].trim() : '';
}

function extractDependsOn(body: string): string[] {
  const line = extractField(body, 'Depends on');
  if (!line) return [];

  // Match task IDs like R1.1, B0.8, ~~B0.8~~ (resolved)
  const ids = line.match(/[RB]\d+\.?\d*\.?\d*/g);
  return ids || [];
}

function extractSpecPath(body: string): string | null {
  const spec = extractField(body, 'Spec');
  if (!spec) return null;
  // Extract path from backticks: `docs/plans/...`
  const pathMatch = spec.match(/`([^`]+)`/);
  return pathMatch ? pathMatch[1] : null;
}

function extractCheckboxes(body: string): { total: number; completed: number } {
  const all = body.match(/- \[[ x]\]/g) || [];
  const checked = body.match(/- \[x\]/g) || [];
  return { total: all.length, completed: checked.length };
}

function extractDescription(body: string): string {
  const why = extractField(body, 'Why');
  if (why) {
    // Take first sentence
    const firstSentence = why.split(/\.\s/)[0];
    return firstSentence.endsWith('.') ? firstSentence : firstSentence + '.';
  }
  return '';
}

function extractCostImpact(body: string): string | null {
  // Match patterns like "$0.85-1.13", "~$5.58", "$0.01/analysis"
  const match = body.match(/~?\$[\d.]+(?:-[\d.]+)?(?:\/\w+)?/);
  return match ? match[0] : null;
}

// â”€â”€â”€ Main Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function parseRoadmap(markdown: string): RoadmapTask[] {
  const lines = markdown.split('\n');
  const tasks: RoadmapTask[] = [];

  let i = 0;
  while (i < lines.length) {
    const line = lines[i];

    // Look for #### task headers
    if (!line.startsWith('#### ')) {
      i++;
      continue;
    }

    const parsed = parseHeader(line);
    if (!parsed) {
      i++;
      continue;
    }

    // Collect body lines until next #### or ### or ---
    const bodyLines: string[] = [];
    let j = i + 1;
    while (j < lines.length && !lines[j].startsWith('#### ') && !lines[j].startsWith('### ') && lines[j] !== '---') {
      bodyLines.push(lines[j]);
      j++;
    }
    const body = bodyLines.join('\n');

    const tier = detectTier(i, lines);
    const status = detectStatus(line, body);
    const priority = extractField(body, 'Priority') || (tier === '0' ? 'P0 - Critical' : '');
    const effort = extractField(body, 'Effort');

    tasks.push({
      id: parsed.id,
      title: parsed.title,
      tier,
      status,
      priority,
      effort,
      dependsOn: extractDependsOn(body),
      specPath: extractSpecPath(body),
      checkboxes: extractCheckboxes(body),
      description: extractDescription(body),
      costImpact: extractCostImpact(body),
      worker: autoAssignWorker(body),
      body,
    });

    i = j;
  }

  return tasks;
}
```

**Step 2: Verify build**

Run: `npm run build 2>&1 | tail -5`
Expected: Build succeeds, no type errors.

**Step 3: Commit**

```bash
git add src/lib/roadmap-parser.ts
git commit -m "feat: add ENGINEERING_ROADMAP.md markdown parser for Kanban dashboard"
```

---

## Task 3: Add git commit info to `next.config.ts`

**Files:**
- Modify: `next.config.ts`

**Step 1: Add git message and date env vars**

The file already has `NEXT_PUBLIC_GIT_COMMIT` for the hash. Add message and date using `execSync`:

In `next.config.ts`, add the import at the top and two new env vars:

```typescript
import type { NextConfig } from "next";
import { version } from "./package.json";
import { execSync } from "child_process";

function getGitInfo(cmd: string, fallback: string): string {
  try {
    return execSync(cmd, { encoding: 'utf-8' }).trim();
  } catch {
    return fallback;
  }
}

const nextConfig: NextConfig = {
  env: {
    NEXT_PUBLIC_APP_VERSION: version,
    NEXT_PUBLIC_GIT_COMMIT:
      process.env.VERCEL_GIT_COMMIT_SHA ||
      process.env.RAILWAY_GIT_COMMIT_SHA ||
      getGitInfo('git rev-parse --short HEAD', 'dev'),
    NEXT_PUBLIC_GIT_MESSAGE:
      process.env.VERCEL_GIT_COMMIT_MESSAGE ||
      getGitInfo('git log -1 --pretty=%s', ''),
    NEXT_PUBLIC_GIT_DATE:
      getGitInfo('git log -1 --pretty=%cI', new Date().toISOString()),
    NEXT_PUBLIC_BUILD_TIME: new Date().toISOString(),
  },
};

export default nextConfig;
```

**Step 2: Verify build**

Run: `npm run build 2>&1 | tail -5`
Expected: Build succeeds.

**Step 3: Commit**

```bash
git add next.config.ts
git commit -m "feat: inject git message and date at build time for roadmap dashboard"
```

---

## Task 4: Create `GET /api/roadmap` endpoint

**Files:**
- Create: `src/app/api/roadmap/route.ts`

**Step 1: Create the endpoint**

Create `src/app/api/roadmap/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { readFileSync } from 'fs';
import { join } from 'path';
import { parseRoadmap, WORKER_INFO } from '@/lib/roadmap-parser';
import { supabase } from '@/db';
import { logger } from '@/lib/logger';

/**
 * GET /api/roadmap
 *
 * Parses ENGINEERING_ROADMAP.md and returns structured tasks with worker assignments.
 */
export async function GET() {
  try {
    // Read the roadmap markdown file
    const roadmapPath = join(process.cwd(), 'docs', 'ENGINEERING_ROADMAP.md');
    let markdown: string;
    try {
      markdown = readFileSync(roadmapPath, 'utf-8');
    } catch {
      return NextResponse.json(
        { error: 'ENGINEERING_ROADMAP.md not found' },
        { status: 404 }
      );
    }

    // Parse markdown into tasks
    const tasks = parseRoadmap(markdown);

    // Fetch manual worker overrides from DB
    const { data: overrides } = await supabase
      .from('roadmap_worker')
      .select('task_id, worker, assigned_by');

    const overrideMap = new Map(
      (overrides || []).map(o => [o.task_id, { worker: o.worker, assignedBy: o.assigned_by }])
    );

    // Apply overrides â€” manual takes precedence over auto
    for (const task of tasks) {
      const override = overrideMap.get(task.id);
      if (override) {
        task.worker = override.worker;
      }
    }

    // Build summary
    const summary = {
      total: tasks.length,
      backlog: tasks.filter(t => t.status === 'backlog').length,
      in_progress: tasks.filter(t => t.status === 'in_progress').length,
      done: tasks.filter(t => t.status === 'done').length,
      byTier: {} as Record<string, number>,
      byWorker: {} as Record<string, { total: number; in_progress: number; done: number }>,
    };

    // Count by tier
    for (const task of tasks) {
      summary.byTier[task.tier] = (summary.byTier[task.tier] || 0) + 1;
    }

    // Count by worker
    for (const workerKey of Object.keys(WORKER_INFO)) {
      const workerTasks = tasks.filter(t => t.worker === workerKey);
      summary.byWorker[workerKey] = {
        total: workerTasks.length,
        in_progress: workerTasks.filter(t => t.status === 'in_progress').length,
        done: workerTasks.filter(t => t.status === 'done').length,
      };
    }

    // Build-time git info (injected by next.config.ts)
    const lastCommit = {
      hash: process.env.NEXT_PUBLIC_GIT_COMMIT || 'unknown',
      message: process.env.NEXT_PUBLIC_GIT_MESSAGE || '',
      date: process.env.NEXT_PUBLIC_GIT_DATE || '',
    };

    return NextResponse.json({ tasks, summary, lastCommit });
  } catch (err) {
    logger.error({ err, route: '/api/roadmap' }, 'Error parsing roadmap');
    return NextResponse.json({ error: 'Failed to parse roadmap' }, { status: 500 });
  }
}
```

**Step 2: Verify build**

Run: `npm run build 2>&1 | tail -10`
Expected: Build succeeds. Route `/api/roadmap` appears in output.

**Step 3: Smoke test**

Run: `npm run dev &` then `curl -s http://localhost:3000/api/roadmap | npx json tasks.length`
Expected: A number (e.g., 30+) â€” the total count of parsed tasks.

Kill dev server when done.

**Step 4: Commit**

```bash
git add src/app/api/roadmap/route.ts
git commit -m "feat: add GET /api/roadmap endpoint with markdown parser integration"
```

---

## Task 5: Create `GET /api/roadmap/workers` endpoint

**Files:**
- Create: `src/app/api/roadmap/workers/route.ts`

**Step 1: Create the endpoint**

Create `src/app/api/roadmap/workers/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { readFileSync } from 'fs';
import { join } from 'path';
import { parseRoadmap, WORKER_INFO } from '@/lib/roadmap-parser';
import { supabase } from '@/db';
import { logger } from '@/lib/logger';

/**
 * GET /api/roadmap/workers
 *
 * Returns FF7 worker list with task counts and assignments.
 */
export async function GET() {
  try {
    // Parse roadmap
    const roadmapPath = join(process.cwd(), 'docs', 'ENGINEERING_ROADMAP.md');
    const markdown = readFileSync(roadmapPath, 'utf-8');
    const tasks = parseRoadmap(markdown);

    // Fetch overrides
    const { data: overrides } = await supabase
      .from('roadmap_worker')
      .select('task_id, worker');

    const overrideMap = new Map(
      (overrides || []).map(o => [o.task_id, o.worker])
    );

    // Apply overrides
    for (const task of tasks) {
      const override = overrideMap.get(task.id);
      if (override) task.worker = override;
    }

    // Build worker stats
    const workers = Object.entries(WORKER_INFO).map(([key, info]) => {
      const workerTasks = tasks.filter(t => t.worker === key);
      return {
        key,
        ...info,
        tasks: {
          total: workerTasks.length,
          backlog: workerTasks.filter(t => t.status === 'backlog').length,
          in_progress: workerTasks.filter(t => t.status === 'in_progress').length,
          done: workerTasks.filter(t => t.status === 'done').length,
        },
        assignments: workerTasks.map(t => t.id),
      };
    });

    return NextResponse.json({ workers });
  } catch (err) {
    logger.error({ err, route: '/api/roadmap/workers' }, 'Error fetching workers');
    return NextResponse.json({ error: 'Failed to fetch workers' }, { status: 500 });
  }
}
```

**Step 2: Verify build**

Run: `npm run build 2>&1 | tail -5`
Expected: Build succeeds.

**Step 3: Commit**

```bash
git add src/app/api/roadmap/workers/route.ts
git commit -m "feat: add GET /api/roadmap/workers endpoint with FF7 character stats"
```

---

## Task 6: Create `PATCH /api/roadmap/assign` endpoint

**Files:**
- Create: `src/app/api/roadmap/assign/route.ts`

**Step 1: Create the endpoint**

Create `src/app/api/roadmap/assign/route.ts`:

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/db';
import { WORKER_INFO } from '@/lib/roadmap-parser';
import { logger } from '@/lib/logger';

const VALID_WORKERS = Object.keys(WORKER_INFO);

/**
 * PATCH /api/roadmap/assign
 *
 * Manually assign or reassign a roadmap task to an FF7 worker.
 * Body: { taskId: string, worker: string }
 */
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json();
    const { taskId, worker } = body as { taskId?: string; worker?: string };

    if (!taskId || typeof taskId !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid "taskId" (string required)' },
        { status: 400 }
      );
    }

    if (!worker || !VALID_WORKERS.includes(worker)) {
      return NextResponse.json(
        { error: `Invalid "worker". Must be one of: ${VALID_WORKERS.join(', ')}` },
        { status: 400 }
      );
    }

    // Upsert: insert or update on conflict
    const { data, error } = await supabase
      .from('roadmap_worker')
      .upsert(
        {
          task_id: taskId,
          worker,
          assigned_at: new Date().toISOString(),
          assigned_by: 'manual',
        },
        { onConflict: 'task_id' }
      )
      .select()
      .single();

    if (error) {
      logger.error({ err: error, route: '/api/roadmap/assign' }, 'Error assigning worker');
      return NextResponse.json({ error: 'Failed to assign worker' }, { status: 500 });
    }

    return NextResponse.json({
      message: `Assigned ${WORKER_INFO[worker].name} to ${taskId}`,
      assignment: data,
    });
  } catch (err) {
    logger.error({ err, route: '/api/roadmap/assign' }, 'Error assigning worker');
    return NextResponse.json({ error: 'Failed to assign worker' }, { status: 500 });
  }
}
```

**Step 2: Verify build**

Run: `npm run build 2>&1 | tail -5`
Expected: Build succeeds.

**Step 3: Commit**

```bash
git add src/app/api/roadmap/assign/route.ts
git commit -m "feat: add PATCH /api/roadmap/assign endpoint for FF7 worker reassignment"
```

---

## Task 7: Update roadmap

**Files:**
- Modify: `docs/ENGINEERING_ROADMAP.md`

**Step 1: Mark backend items as complete in R1.5.5**

Update the R1.5.5 section in `docs/ENGINEERING_ROADMAP.md`:

Change the backend checkboxes from `- [ ]` to `- [x]`:

```markdown
**Backend:**
- [x] Markdown parser: extracts task ID, title, status, tier, priority, effort, dependencies, spec path, checkboxes, description, cost impact from ENGINEERING_ROADMAP.md
- [x] `GET /api/roadmap` returns parsed tasks + summary statistics + last git commit info
- [x] `GET /api/roadmap/workers` returns FF7 worker list with task counts
- [x] `PATCH /api/roadmap/assign` stores/updates worker override in `roadmap_worker` table
- [x] `roadmap_worker` table created via Supabase migration
- [x] Auto-assignment heuristic: domain keywords â†’ FF7 character mapping (Cloud=Backend, Tifa=Frontend, Barret=Infra, Aerith=PM, Red XIII=QA)
```

**Step 2: Commit and push**

```bash
git add docs/ENGINEERING_ROADMAP.md
git commit -m "docs: mark R1.5.5 backend items complete in roadmap"
git push
```

---

## Frontend Tasks (for frontend agent)

The following tasks require the `frontend-designer` skill and should be done by a frontend agent session:

### Frontend Task A: `/roadmap` page + Kanban board
- `/roadmap` page at `src/app/roadmap/page.tsx`
- `RoadmapBoard` component with 3 columns (Backlog / In Progress / Done)
- Fetches from `GET /api/roadmap`, polls every 30s

### Frontend Task B: Worker bar
- `WorkerBar` component with FF7 character avatars
- Click to filter board by worker
- Pulse animation on workers with in_progress tasks

### Frontend Task C: Task cards
- `TaskCard` component with worker avatar, tier badge, progress bar, dependencies
- Click to expand full detail view
- Worker reassignment dropdown (calls `PATCH /api/roadmap/assign`)

### Frontend Task D: Filters + search
- Tier filter dropdown
- Free text search on task ID/title
- Add "Roadmap" tab to `nav.tsx`
