# R1.6 Products as First-Class Entity — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Elevate products to a first-class entity with their own table, CRUD API, and pipeline integration so products are analyzed once and reused across projects.

**Architecture:** New `product` table with full CRUD API endpoints following the existing influencer pattern. Worker writes analysis results to the product table first, then copies denormalized fields to the project. Project creation accepts an optional `productId` to skip re-analysis.

**Tech Stack:** Next.js 16 App Router API routes, Supabase (PostgreSQL + Storage), zod validation, pino logging, BullMQ worker

**Supabase Project ID:** `yuiwwmkalyplhcwgwcap`

---

### Task 1: Database Migration — Create `product` table

**Files:**
- Supabase migration via MCP (apply_migration)

**Step 1: Apply migration to create `product` table**

```sql
CREATE TABLE product (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  url text NOT NULL UNIQUE,
  name text,
  brand text,
  category text,
  product_type text,
  product_size text,
  product_price text,
  selling_points jsonb DEFAULT '[]'::jsonb,
  key_claims jsonb DEFAULT '[]'::jsonb,
  benefits jsonb DEFAULT '[]'::jsonb,
  usage text,
  hook_angle text,
  avatar_description text,
  image_description text,
  image_url text,
  analysis_data jsonb,
  overrides jsonb DEFAULT '{}'::jsonb,
  status text NOT NULL DEFAULT 'created',
  error_message text,
  cost_usd numeric(10,4) DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE INDEX idx_product_url ON product(url);
CREATE INDEX idx_product_status ON product(status);
```

**Step 2: Apply migration to add `product_id` FK to `project` table**

```sql
ALTER TABLE project ADD COLUMN product_id uuid REFERENCES product(id);
CREATE INDEX idx_project_product_id ON project(product_id);
```

**Step 3: Update schema docs**

Update `src/db/schema.ts` to add the `product` table definition and add `productId` to the `project` table, following the existing Drizzle pattern.

**Step 4: Commit**

```
feat(db): add product table and product_id FK on project (R1.6)
```

---

### Task 2: Products List & Create API — `GET/POST /api/products`

**Files:**
- Create: `src/app/api/products/route.ts`

**Step 1: Create the route file**

`GET /api/products` — List all products, ordered by created_at desc. Include a `project_count` by joining project table.

`POST /api/products` — Accepts `{ url }`. Validates URL with zod. Checks for duplicate URL:
- If product exists with status `analyzed`: return existing product (200)
- If product exists with status `analyzing`: return existing product (200)
- If product exists with status `failed`: re-enqueue analysis, return product (200)
- If no match: insert new product with status `created`, enqueue `product_analysis` job with `{ productId, step: 'product_analysis' }`, return 201

Follow the `influencers/route.ts` pattern exactly for structure, error handling, and logging.

**Step 2: Commit**

```
feat(api): add GET/POST /api/products with duplicate URL detection (R1.6)
```

---

### Task 3: Product Detail API — `GET/PATCH/DELETE /api/products/[id]`

**Files:**
- Create: `src/app/api/products/[id]/route.ts`

**Step 1: Create the route file**

`GET /api/products/[id]` — Fetch product by ID. Also fetch project count referencing this product.

`PATCH /api/products/[id]` — Accepts partial updates for any editable field: name, brand, category, product_type, product_size, product_price, selling_points, key_claims, benefits, usage, hook_angle, avatar_description, image_description. Validate category against `PRODUCT_CATEGORIES`. Track overridden fields in `overrides` JSONB column (merge new overrides with existing). Support `reset` array: `{ reset: ["field_name"] }` restores original value from `analysis_data` and removes from `overrides`.

`DELETE /api/products/[id]` — Guard: count projects referencing this product. If count > 0, return 409. Otherwise delete.

Follow `influencers/[id]/route.ts` pattern for params handling, error handling, logging.

**Step 2: Commit**

```
feat(api): add GET/PATCH/DELETE /api/products/[id] with override tracking (R1.6)
```

---

### Task 4: Product Image Upload — `POST /api/products/[id]/image`

**Files:**
- Create: `src/app/api/products/[id]/image/route.ts`

**Step 1: Create the route file**

Follow `projects/[id]/product-image/route.ts` pattern exactly:
- Accept FormData with `image` file
- Verify product exists
- Upload to Supabase Storage at `products/{productId}/product.{ext}`
- Convert File to Buffer via `Buffer.from(await file.arrayBuffer())`
- Get public URL, update product `image_url` column
- Return `{ url: publicUrl }`

**Step 2: Commit**

```
feat(api): add POST /api/products/[id]/image for product image upload (R1.6)
```

---

### Task 5: Product Reanalyze — `POST /api/products/[id]/reanalyze`

**Files:**
- Create: `src/app/api/products/[id]/reanalyze/route.ts`

**Step 1: Create the route file**

- Verify product exists
- Set product status to `analyzing`
- Enqueue `product_analysis` job with `{ productId: id, step: 'product_analysis' }`
- Return `{ message: 'Reanalysis enqueued', productId: id }`

The worker (Task 7) will handle preserving overridden fields on re-analysis.

**Step 2: Commit**

```
feat(api): add POST /api/products/[id]/reanalyze endpoint (R1.6)
```

---

### Task 6: Update Project Creation — Accept `productId`

**Files:**
- Modify: `src/app/api/projects/route.ts`

**Step 1: Update the zod schema and POST handler**

Add to `createProjectSchema`:
- `productId: z.string().uuid().optional()`
- Make `productUrl` optional (one of `productId` or `productUrl` required)

POST logic:
- If `productId` provided: fetch the product. If product status is `analyzed`, copy denormalized fields (product_name, product_category, product_image_url, product_data) to the new project. Set project status to `analysis_review` (user still reviews). Do NOT enqueue product_analysis.
- If `productUrl` provided (no productId): check if a product with that URL exists. If yes, link to it (set product_id on project). If no, create a new product record, link it, then enqueue product_analysis.
- Store `product_id` on the project in both paths.

**Step 2: Commit**

```
feat(api): project creation accepts productId to skip re-analysis (R1.6)
```

---

### Task 7: Pipeline Worker — Write Analysis to Product Table

**Files:**
- Modify: `src/workers/pipeline.worker.ts`

**Step 1: Update `handleProductAnalysis` function**

After the agent returns `analysis`:
1. Fetch the project to get `product_id`
2. If project has a `product_id`, write analysis results to the `product` table:
   - All analysis fields (name, brand, category, etc.)
   - `analysis_data`: full raw analysis JSON
   - `status: 'analyzed'`
   - Respect `overrides`: fetch existing product, check `overrides` JSONB. For any field listed in overrides, do NOT overwrite.
   - `cost_usd`: increment with API_COSTS.wavespeedChat
3. Then write denormalized fields to the `project` table as before (backward compat)

Also update the worker's job dispatch to handle `productId` in job data (for standalone product analysis triggered by POST /api/products).

Add a new condition in the worker: if job data has `productId` but no `projectId`, run analysis against the product table only (no project update).

**Step 2: Commit**

```
feat(worker): write analysis to product table with override preservation (R1.6)
```

---

### Task 8: Update Schema Docs

**Files:**
- Modify: `src/db/schema.ts`

**Step 1: Add product table and relations to schema.ts**

Add `product` pgTable definition with all columns. Add `productId` to the `project` table. Add relations: product has many projects, project optionally belongs to product.

**Step 2: Commit**

```
docs(schema): add product table and product_id FK to schema.ts (R1.6)
```

---

### Task 9: Verify Build

**Step 1: Run `npm run build`**

Verify no TypeScript errors. Fix any issues.

**Step 2: Verify migrations applied**

Use Supabase MCP `list_tables` to confirm `product` table exists with correct columns.

**Step 3: Final commit if fixes needed**

```
fix: resolve build issues from R1.6 implementation
```

---

## Execution Order

```
Task 1 (migration)  ──→  Task 8 (schema docs)
                     ──→  Task 2 (list/create API)  ──→  Task 3 (detail API)  ──→  Task 4 (image upload)  ──→  Task 5 (reanalyze)
                     ──→  Task 6 (project creation)  ──→  Task 7 (worker)
                                                                                                              ──→  Task 9 (verify)
```

Tasks 2-5 are sequential (each builds on the previous). Task 6-7 are sequential. Tasks 2 and 6 can run in parallel after Task 1. Task 9 runs last.

## Notes

- No test framework exists in this project. Tests are deferred.
- Frontend work (Products tab, list page, detail page, inline editing) is out of scope — flagged for a frontend agent.
- Old projects without `product_id` continue to work unchanged (backward compat).
