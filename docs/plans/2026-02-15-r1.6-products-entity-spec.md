# R1.6 - Products as First-Class Entity

**Date:** 2026-02-15
**Status:** SPEC - Pending Admin Approval
**Priority:** P0 - Critical (Tier 1)
**Effort:** Medium

---

## Problem Statement

Product data is fully denormalized into the `project` table. Every project re-runs ProductAnalyzerAgent from scratch, even for the same product URL. This means:

1. **Wasted API costs** — Same product analyzed N times at $0.01 each
2. **Wasted user time** — User must review and approve analysis every time
3. **No product library** — User can't browse their analyzed products
4. **No cross-project insights** — Can't ask "how many videos have I made for Product X?"
5. **Product image stored per-project** — Same product image uploaded N times to different storage paths

## Solution

Elevate products to a first-class entity with their own table, CRUD API, and UI tab.

**Core principle:** Analyze once, use across many projects.

---

## Data Model

### New `product` table

| Column | Type | Description |
|--------|------|-------------|
| `id` | uuid (PK) | Auto-generated |
| `url` | text (required, unique) | TikTok Shop product URL |
| `name` | text | Extracted product name (from analysis) |
| `brand` | text | Extracted brand |
| `category` | text | One of 10 product categories |
| `product_type` | text | e.g., "Vitamin C Serum", "Resistance Bands" |
| `product_size` | text | e.g., "30ml", "Set of 3" |
| `product_price` | text | e.g., "$24.99" |
| `selling_points` | jsonb | Array of 3-5 selling points |
| `key_claims` | jsonb | Array of 3-5 claims with numbers |
| `benefits` | jsonb | Array of 3-5 benefits |
| `usage` | text | 1-2 sentence usage description |
| `hook_angle` | text | TikTok strategy angle |
| `avatar_description` | text | Authority figure description |
| `image_description` | text | `image_description_for_nano_banana_pro` from analysis |
| `image_url` | text | Product image URL (from extraction or user upload) |
| `analysis_data` | jsonb | Full raw analysis JSON (preserves original LLM output for reference) |
| `overrides` | jsonb | Tracks which fields the user has manually edited (e.g., `{"selling_points": true, "hook_angle": true}`). Re-analyze preserves overridden fields unless user requests full reset. |
| `status` | text | `created` / `analyzing` / `analyzed` / `failed` |
| `error_message` | text | Error details if analysis failed |
| `cost_usd` | numeric | Cost of analysis ($0.01 per LLM call) |
| `created_at` | timestamptz | Auto-set |
| `updated_at` | timestamptz | Auto-set on update |

### Project table changes

| Change | Details |
|--------|---------|
| **Add** `product_id` | uuid FK → `product.id` (required for new projects) |
| **Keep** `product_url` | Retained for backward compat on old projects (nullable, deprecated) |
| **Keep** `product_name`, `product_category` | Denormalized copies for quick display (populated from product on project creation) |
| **Keep** `product_data` | Retained for old projects; new projects reference `product.analysis_data` |
| **Keep** `product_image_url` | Retained for old projects; new projects use `product.image_url` |

### Migration strategy

- Old projects (no `product_id`) continue to work — read from their own `product_*` columns
- New projects created with `product_id` — product data comes from the `product` table
- Optional one-time migration: deduplicate old projects by URL, create product records, backfill `product_id`

---

## API Endpoints

### Products CRUD

| Method | Route | Description |
|--------|-------|-------------|
| `GET` | `/api/products` | List all products (with project count per product) |
| `POST` | `/api/products` | Create product from URL + enqueue analysis |
| `GET` | `/api/products/[id]` | Product detail (includes analysis data + project list) |
| `PATCH` | `/api/products/[id]` | Update any product field (manual overrides — see editable fields below) |
| `DELETE` | `/api/products/[id]` | Delete product (guard: 409 if referenced by projects) |
| `POST` | `/api/products/[id]/image` | Upload/replace product image |
| `POST` | `/api/products/[id]/reanalyze` | Re-run analysis (for updated product pages) |

### Editable Product Fields (PATCH overrides)

All LLM-extracted fields are user-overridable via `PATCH /api/products/[id]`. The user should be able to refine any analysis output to better match reality or their creative intent.

| Field | Type | Why Editable |
|-------|------|-------------|
| `name` | text | LLM may extract wrong name or abbreviate |
| `brand` | text | Brand detection can miss or hallucinate |
| `category` | text (enum) | LLM may miscategorize (e.g., "supplements" vs "skincare") |
| `product_type` | text | Refine product descriptor |
| `product_size` | text | Correct sizing info |
| `product_price` | text | Update if price changed |
| `selling_points` | jsonb array | **Core override** — user knows their product's real selling points better than LLM |
| `key_claims` | jsonb array | **Core override** — user can add verified claims with real data/numbers |
| `benefits` | jsonb array | **Core override** — user can emphasize benefits that actually convert |
| `usage` | text | Refine usage instructions |
| `hook_angle` | text | **Core override** — user can inject their own TikTok strategy angle |
| `avatar_description` | text | **Core override** — user can customize the authority figure description for casting |
| `image_description` | text | Adjust the AI image generation prompt for the product |

**PATCH behavior:**
- Accepts partial updates (only send fields that changed)
- Each field is independently overridable — user can edit one field without losing others
- When a field is overridden, it takes precedence over the original LLM analysis
- `analysis_data` JSONB preserves the original LLM output for reference/comparison
- Track `updated_at` timestamp on every edit
- Overridden fields should be visually distinguished in the UI (e.g., "Edited" badge or different styling)

**Re-analyze behavior:**
- `POST /api/products/[id]/reanalyze` re-runs the LLM on the product URL
- Overwrites all auto-extracted fields with fresh analysis
- **Does NOT overwrite user-edited fields** unless the user explicitly requests a full reset
- To support this: add `overrides` JSONB column that stores which fields the user has manually edited. On re-analyze, skip fields listed in `overrides`.

### Project creation changes

`POST /api/projects` accepts either:
- `productId` — existing analyzed product (skip analysis, go straight to scripting or analysis_review if image missing)
- `productUrl` — new URL (auto-creates product if URL not seen before, or links to existing product if URL matches)

### Duplicate URL detection

On `POST /api/products` or `POST /api/projects` with `productUrl`:
1. Check if a product with that URL already exists
2. If yes and status is `analyzed`: return existing product (no re-analysis)
3. If yes and status is `analyzing`: return existing product (analysis in progress)
4. If yes and status is `failed`: offer to re-analyze
5. If no: create new product, enqueue analysis

---

## Frontend

### Products Tab (new)

- **Navigation:** Add "Products" tab to `nav.tsx` (between Projects and Influencers)
- **Products list page** (`/products`): Grid of product cards showing name, category, image thumbnail, status badge, project count, created date
- **Product detail page** (`/products/[id]`): Full analysis display (reuse AnalysisResults component pattern from project-detail), product image with upload/replace, list of projects using this product, delete button with guard

### Product Cards

| Field | Display |
|-------|---------|
| Product image | Thumbnail (or placeholder if no image) |
| Product name | Title |
| Category | Badge |
| Status | analyzing / analyzed / failed badge |
| Project count | "Used in N projects" |
| Created date | Relative time |

### Create Project Form changes

- **Add product selector:** Dropdown/search of existing analyzed products
- **Or enter new URL:** Falls back to current URL input
- When existing product selected: show product summary card, skip to tone/influencer selection
- When new URL entered: creates product and project, runs analysis as usual

### Product Detail Page

- Analysis results (same display as current project analysis section)
- Product image section with upload/replace (same pattern as current ProductImageSection)
- "Projects using this product" list with links
- "Create New Video" button → pre-fills create project form with this product
- Re-analyze button (for when product page has been updated)
- Delete button (guarded if projects reference it)

**Inline editing for all analysis fields:**
- Every analysis field is editable directly on the product detail page
- Click-to-edit or toggle "Edit Mode" that makes all fields editable at once
- Editable fields: name, brand, category (dropdown), product_type, product_size, product_price, selling_points (add/remove/reorder items), key_claims (add/remove/reorder items), benefits (add/remove/reorder items), usage (text area), hook_angle (text area), avatar_description (text area), image_description (text area)
- Array fields (selling_points, key_claims, benefits): inline list editor with add item, remove item, drag-to-reorder, edit individual items
- Text fields: click to edit, enter to save, escape to cancel
- Dropdown fields (category): select from 10 valid categories
- Save/cancel buttons in edit mode; auto-save per field in click-to-edit mode
- "Edited" badge shown next to fields the user has manually overridden (tracked via `overrides` column)
- "Reset to original" option per field — reverts to the original LLM-extracted value from `analysis_data`
- Side-by-side or diff view option: show original LLM value alongside user override for comparison

---

## Pipeline Changes

### ProductAnalyzerAgent

- Input: `product` record (not `project`)
- Output: writes analysis back to `product` table (not `project`)
- No agent code change needed beyond which table it reads/writes

### Pipeline Worker

- `handleProductAnalysis` step: update `product` record instead of `project` record
- After product analysis completes: also update the `project` record's denormalized fields (`product_name`, `product_category`, `product_image_url`) from the product
- Set product status to `analyzed`, project status to `analysis_review`

### Project creation with existing product

- If `productId` provided and product is `analyzed`:
  - Copy denormalized fields to project
  - Skip analysis, set project status to `analysis_review` (for image gate check) or `script_review` if image already present
  - User still reviews analysis on project detail (reads from product), but doesn't wait for LLM

---

## Acceptance Criteria

### Backend
- [ ] `product` table created via Supabase migration (includes `overrides` jsonb column)
- [ ] `product_id` FK column added to `project` table
- [ ] Full CRUD API for products (`/api/products`, `/api/products/[id]`)
- [ ] PATCH accepts all editable fields: name, brand, category, product_type, product_size, product_price, selling_points, key_claims, benefits, usage, hook_angle, avatar_description, image_description
- [ ] PATCH tracks which fields are user-overridden in `overrides` column
- [ ] Product image upload/replace endpoint (`/api/products/[id]/image`)
- [ ] Reanalyze endpoint (`/api/products/[id]/reanalyze`) — preserves user-overridden fields (reads `overrides` column), only refreshes non-overridden fields
- [ ] Reset-to-original per field: PATCH with `{ reset: ["field_name"] }` restores original value from `analysis_data` and removes from `overrides`
- [ ] Duplicate URL detection on product creation
- [ ] `POST /api/projects` accepts `productId` and skips analysis for analyzed products
- [ ] ProductAnalyzerAgent writes to `product` table
- [ ] Pipeline worker updates both `product` and `project` after analysis
- [ ] Delete guard: 409 if product referenced by projects

### Frontend
- [ ] Products tab in navigation
- [ ] Products list page (`/products`) with cards, status badges, project count
- [ ] Product detail page (`/products/[id]`) with analysis, image, project list
- [ ] Inline editing for all analysis fields (text fields: click-to-edit; arrays: add/remove/reorder; category: dropdown)
- [ ] "Edited" badge on overridden fields (driven by `overrides` column)
- [ ] "Reset to original" per-field action (reverts to LLM-extracted value from `analysis_data`)
- [ ] Product image upload/replace on detail page
- [ ] Create project form: product selector + new URL input
- [ ] Product card delete with confirmation dialog
- [ ] Product detail delete with confirmation dialog

### Data integrity
- [ ] Old projects without `product_id` continue to work (read from own columns)
- [ ] New projects with `product_id` read product data from `product` table
- [ ] Product deletion blocked if referenced by active projects
- [ ] `analysis_data` always preserves the original LLM output (never mutated by user edits)
- [ ] User edits stored in top-level columns; `analysis_data` is the immutable baseline

---

## Parallel Work Analysis

```
PARALLEL WORK ANALYSIS:
- Task A (backend): Product table migration + CRUD API + image upload
  Files: Supabase migration, src/app/api/products/**, src/app/api/products/[id]/**
  Independent: YES (new files, no conflicts)

- Task B (backend): Pipeline changes (ProductAnalyzerAgent → writes to product table, worker updates)
  Files: src/agents/product-analyzer.ts, src/workers/pipeline.worker.ts, src/app/api/projects/route.ts
  BLOCKED by Task A (needs product table to exist)

- Task C (frontend): Products tab, list page, detail page, cards
  Files: src/components/product-card.tsx, src/components/product-list.tsx, src/components/product-detail.tsx,
         src/app/products/**, src/components/nav.tsx
  PARTIALLY BLOCKED by Task A (needs API endpoints to fetch data)
  CAN START: UI shell with mocked data

- Task D (frontend): Create project form product selector
  Files: src/components/create-project-form.tsx
  BLOCKED by Task A + Task B (needs product API + project creation changes)

Recommendation:
  Step 1: Task A (backend CRUD) + Task C UI shell (frontend, mocked) — in parallel
  Step 2: Task B (pipeline changes) — after Task A
  Step 3: Task C wiring + Task D (frontend integration) — after Task A + B
```
